{"version":3,"file":"src_app_http-client-services_http-client-services_module_ts.js","mappings":";;;;;;;;;;;;;;;;AACuD;AACwB;;;AAE/E,MAAM,MAAM,GAAW;IACrB,EAAC,IAAI,EAAC,EAAE,EAAE,SAAS,EAAE,wFAA2B;QAC9C,QAAQ,EAAE,EAET;KACF;CACF,CAAC;AAMK,MAAM,+BAA+B;;8GAA/B,+BAA+B;4HAA/B,+BAA+B;gIAHjC,CAAC,kEAAqB,CAAC,MAAM,CAAC,CAAC,EAC9B,yDAAY;mIAEX,+BAA+B,oFAFhC,yDAAY;;;;;;;;;;;;;;;;;;;;ACbS;AACG;;;;;ICWjC,qEAA2B;IACxB,qEAAI;IAAA,uDAAoB;IAAA,4DAAK;IAChC,4DAAK;;;IADE,0DAAoB;IAApB,kGAAoB;;ADLvB,MAAM,2BAA2B;IAIrC;QAFA,UAAK,GAAG,EAAE,CAAC;QAGR,iBAAiB;QACjB,IAAI,CAAC,KAAK,GAAG,yBAAyB,CAAC;QACvC,IAAI,CAAC,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;IAC1B,CAAC;IACD,OAAO;QACJ,MAAM,QAAQ,GAAI,+CAAI,CAAC,4CAA4C,CAAC;aAChE,IAAI,CAAC,mDAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;QAC7B,QAAQ,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE;YACxB,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;YACjB,IAAI,CAAC,IAAI,GAAG,GAAG,CAAC;QACnB,CAAC,CAAC,CAAC;IACN,CAAC;IAEF,QAAQ;IACR,CAAC;;sGAnBU,2BAA2B;yHAA3B,2BAA2B;QCTxC,sEAAK;QACD,uEAA2C;QAAC,iFAAqB;QAAA,4DAAI;QAAC,+DACtE;QAAA,uEAAiD;QAAC,mFAAuB;QAAA,4DAAI;QAAG,+DAChF;QAAA,uEAAuD;QAAC,wFAA4B;QAAA,4DAAI;QAAC,+DACzF;QAAA,wEAA2C;QAAC,uFAA0B;QAAA,4DAAI;QAC7E,4DAAM;QAEN,4EAA+B;QAE/B,qHAEA;QAAA,uEAAK;QACH,sEAAI;QAAA,wDAAS;QAAA,4DAAK;QAClB,uHAEK;QACR,4DAAM;;QAJC,2DAAS;QAAT,0EAAS;QACK,0DAAO;QAAP,6EAAO;;;;;;;;;;;;;;;;;;;;ACZmB;AAEyC;AACT;;AAWxE,MAAM,wBAAwB;;gGAAxB,wBAAwB;qHAAxB,wBAAwB;yHAL1B;YACP,yDAAY;YACZ,iGAA+B;SAChC;mIAEU,wBAAwB,mBAPjC,wFAA2B,aAG3B,yDAAY;QACZ,iGAA+B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACZI;AACO;AACA;AACJ;AAC1C;AACA,QAAQ,2DAAmB;AAC3B,mBAAmB,2DAAmB;AACtC;AACA,eAAe,2DAAmB;AAClC,mBAAmB,2DAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAmB;AAC3B,mBAAmB,2DAAmB;AACtC;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA,4BAA4B,0DAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0DAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gCAAgC,6BAA6B;AAC7D;AACO;AACP,gCAAgC,oCAAoC;AACpE;AACO;AACP,gCAAgC,gCAAgC;AAChE;AACO;AACP,gCAAgC,mCAAmC;AACnE;AACO;AACP,gCAAgC,qCAAqC;AACrE;AACA,oBAAoB,mDAAG;AAChB;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO,6BAA6B,mDAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM,6BAA6B,mDAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,qDAAa,4BAA4B,qDAAa;AAC1F,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4BAA4B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB,sDAAsD;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qDAAa,oBAAoB,qDAAa;AAC/D;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,wBAAwB,GAAG,8BAA8B;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0CAA0C;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA,oBAAoB,2DAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0CAA0C;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0CAA0C;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;;;;;;;;;;;;;;;;ACrW2C;AAC3C,oBAAoB,kEAAqB;;;;;;;;;;;;;;;ACDhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACwB","sources":["./src/app/http-client-services/http-client-services-routing.module.ts","./src/app/http-client-services/http-client-services.component.ts","./src/app/http-client-services/http-client-services.component.html","./src/app/http-client-services/http-client-services.module.ts","./node_modules/rxjs/_esm2015/internal/observable/dom/AjaxObservable.js","./node_modules/rxjs/_esm2015/internal/observable/dom/ajax.js","./node_modules/rxjs/_esm2015/internal/util/root.js"],"sourcesContent":["import { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { HttpClientServicesComponent } from './http-client-services.component';\n\nconst routes: Routes = [\n  {path:'', component: HttpClientServicesComponent,\n    children: [\n\n    ]\n  }\n];\n\n@NgModule({\n  imports: [RouterModule.forChild(routes)],\n  exports: [RouterModule]\n})\nexport class HttpClientServicesRoutingModule { }\n","import { Component, OnInit } from '@angular/core';\nimport { ajax } from 'rxjs/ajax';\nimport { map } from 'rxjs/operators'\n\n@Component({\n  selector: 'app-http-client-services',\n  templateUrl: './http-client-services.component.html',\n  styleUrls: ['./http-client-services.component.less']\n})\nexport class HttpClientServicesComponent implements OnInit {\n\n   title = '';\n   data :any;\n   constructor() {\n      //this.data = \"\";\n      this.title = \"Using RxJs with Angular\";\n      let a = this.getData();\n   }\n   getData() {\n      const response =  ajax('https://jsonplaceholder.typicode.com/users')\n         .pipe(map(e => e.response));\n        response.subscribe(res => {\n         console.log(res);\n         this.data = res;\n      });\n   }\n\n  ngOnInit(): void {\n  }\n\n}\n","<nav> \n    <a routerLink=\"/http-client-services/http\"> Http API call feature</a> || \n    <a routerLink=\"/http-client-services/diServices\"> Services - sharing data</a>   || \n    <a routerLink=\"/http-client-services/getpostputdelete\"> Http , Methods - Status code</a> ||       \n    <a routerLink=\"/http-client-services/rxjs\"> rxjs - Observable, Promise</a>      \n </nav>\n\n <router-outlet></router-outlet>\n\n Http call without httpClient , module using rxjs / ajax \n\n <div>\n   <h3>{{title}}</h3>\n   <ul *ngFor=\"let i of data\">\n      <li>{{i.id}}: {{i.name}}</li>\n   </ul>\n</div>","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\nimport { HttpClientServicesRoutingModule } from './http-client-services-routing.module';\nimport { HttpClientServicesComponent } from './http-client-services.component';\n\n@NgModule({\n  declarations: [\n    HttpClientServicesComponent\n  ],\n  imports: [\n    CommonModule,\n    HttpClientServicesRoutingModule\n  ]\n})\nexport class HttpClientServicesModule { }\n","import { root } from '../../util/root';\nimport { Observable } from '../../Observable';\nimport { Subscriber } from '../../Subscriber';\nimport { map } from '../../operators/map';\nfunction getCORSRequest() {\n    if (root.XMLHttpRequest) {\n        return new root.XMLHttpRequest();\n    }\n    else if (!!root.XDomainRequest) {\n        return new root.XDomainRequest();\n    }\n    else {\n        throw new Error('CORS is not supported by your browser');\n    }\n}\nfunction getXMLHttpRequest() {\n    if (root.XMLHttpRequest) {\n        return new root.XMLHttpRequest();\n    }\n    else {\n        let progId;\n        try {\n            const progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];\n            for (let i = 0; i < 3; i++) {\n                try {\n                    progId = progIds[i];\n                    if (new root.ActiveXObject(progId)) {\n                        break;\n                    }\n                }\n                catch (e) {\n                }\n            }\n            return new root.ActiveXObject(progId);\n        }\n        catch (e) {\n            throw new Error('XMLHttpRequest is not supported by your browser');\n        }\n    }\n}\nexport function ajaxGet(url, headers = null) {\n    return new AjaxObservable({ method: 'GET', url, headers });\n}\nexport function ajaxPost(url, body, headers) {\n    return new AjaxObservable({ method: 'POST', url, body, headers });\n}\nexport function ajaxDelete(url, headers) {\n    return new AjaxObservable({ method: 'DELETE', url, headers });\n}\nexport function ajaxPut(url, body, headers) {\n    return new AjaxObservable({ method: 'PUT', url, body, headers });\n}\nexport function ajaxPatch(url, body, headers) {\n    return new AjaxObservable({ method: 'PATCH', url, body, headers });\n}\nconst mapResponse = map((x, index) => x.response);\nexport function ajaxGetJSON(url, headers) {\n    return mapResponse(new AjaxObservable({\n        method: 'GET',\n        url,\n        responseType: 'json',\n        headers\n    }));\n}\nexport class AjaxObservable extends Observable {\n    constructor(urlOrRequest) {\n        super();\n        const request = {\n            async: true,\n            createXHR: function () {\n                return this.crossDomain ? getCORSRequest() : getXMLHttpRequest();\n            },\n            crossDomain: true,\n            withCredentials: false,\n            headers: {},\n            method: 'GET',\n            responseType: 'json',\n            timeout: 0\n        };\n        if (typeof urlOrRequest === 'string') {\n            request.url = urlOrRequest;\n        }\n        else {\n            for (const prop in urlOrRequest) {\n                if (urlOrRequest.hasOwnProperty(prop)) {\n                    request[prop] = urlOrRequest[prop];\n                }\n            }\n        }\n        this.request = request;\n    }\n    _subscribe(subscriber) {\n        return new AjaxSubscriber(subscriber, this.request);\n    }\n}\nAjaxObservable.create = (() => {\n    const create = (urlOrRequest) => {\n        return new AjaxObservable(urlOrRequest);\n    };\n    create.get = ajaxGet;\n    create.post = ajaxPost;\n    create.delete = ajaxDelete;\n    create.put = ajaxPut;\n    create.patch = ajaxPatch;\n    create.getJSON = ajaxGetJSON;\n    return create;\n})();\nexport class AjaxSubscriber extends Subscriber {\n    constructor(destination, request) {\n        super(destination);\n        this.request = request;\n        this.done = false;\n        const headers = request.headers = request.headers || {};\n        if (!request.crossDomain && !this.getHeader(headers, 'X-Requested-With')) {\n            headers['X-Requested-With'] = 'XMLHttpRequest';\n        }\n        let contentTypeHeader = this.getHeader(headers, 'Content-Type');\n        if (!contentTypeHeader && !(root.FormData && request.body instanceof root.FormData) && typeof request.body !== 'undefined') {\n            headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';\n        }\n        request.body = this.serializeBody(request.body, this.getHeader(request.headers, 'Content-Type'));\n        this.send();\n    }\n    next(e) {\n        this.done = true;\n        const { xhr, request, destination } = this;\n        let result;\n        try {\n            result = new AjaxResponse(e, xhr, request);\n        }\n        catch (err) {\n            return destination.error(err);\n        }\n        destination.next(result);\n    }\n    send() {\n        const { request, request: { user, method, url, async, password, headers, body } } = this;\n        try {\n            const xhr = this.xhr = request.createXHR();\n            this.setupEvents(xhr, request);\n            if (user) {\n                xhr.open(method, url, async, user, password);\n            }\n            else {\n                xhr.open(method, url, async);\n            }\n            if (async) {\n                xhr.timeout = request.timeout;\n                xhr.responseType = request.responseType;\n            }\n            if ('withCredentials' in xhr) {\n                xhr.withCredentials = !!request.withCredentials;\n            }\n            this.setHeaders(xhr, headers);\n            if (body) {\n                xhr.send(body);\n            }\n            else {\n                xhr.send();\n            }\n        }\n        catch (err) {\n            this.error(err);\n        }\n    }\n    serializeBody(body, contentType) {\n        if (!body || typeof body === 'string') {\n            return body;\n        }\n        else if (root.FormData && body instanceof root.FormData) {\n            return body;\n        }\n        if (contentType) {\n            const splitIndex = contentType.indexOf(';');\n            if (splitIndex !== -1) {\n                contentType = contentType.substring(0, splitIndex);\n            }\n        }\n        switch (contentType) {\n            case 'application/x-www-form-urlencoded':\n                return Object.keys(body).map(key => `${encodeURIComponent(key)}=${encodeURIComponent(body[key])}`).join('&');\n            case 'application/json':\n                return JSON.stringify(body);\n            default:\n                return body;\n        }\n    }\n    setHeaders(xhr, headers) {\n        for (let key in headers) {\n            if (headers.hasOwnProperty(key)) {\n                xhr.setRequestHeader(key, headers[key]);\n            }\n        }\n    }\n    getHeader(headers, headerName) {\n        for (let key in headers) {\n            if (key.toLowerCase() === headerName.toLowerCase()) {\n                return headers[key];\n            }\n        }\n        return undefined;\n    }\n    setupEvents(xhr, request) {\n        const progressSubscriber = request.progressSubscriber;\n        function xhrTimeout(e) {\n            const { subscriber, progressSubscriber, request } = xhrTimeout;\n            if (progressSubscriber) {\n                progressSubscriber.error(e);\n            }\n            let error;\n            try {\n                error = new AjaxTimeoutError(this, request);\n            }\n            catch (err) {\n                error = err;\n            }\n            subscriber.error(error);\n        }\n        xhr.ontimeout = xhrTimeout;\n        xhrTimeout.request = request;\n        xhrTimeout.subscriber = this;\n        xhrTimeout.progressSubscriber = progressSubscriber;\n        if (xhr.upload && 'withCredentials' in xhr) {\n            if (progressSubscriber) {\n                let xhrProgress;\n                xhrProgress = function (e) {\n                    const { progressSubscriber } = xhrProgress;\n                    progressSubscriber.next(e);\n                };\n                if (root.XDomainRequest) {\n                    xhr.onprogress = xhrProgress;\n                }\n                else {\n                    xhr.upload.onprogress = xhrProgress;\n                }\n                xhrProgress.progressSubscriber = progressSubscriber;\n            }\n            let xhrError;\n            xhrError = function (e) {\n                const { progressSubscriber, subscriber, request } = xhrError;\n                if (progressSubscriber) {\n                    progressSubscriber.error(e);\n                }\n                let error;\n                try {\n                    error = new AjaxError('ajax error', this, request);\n                }\n                catch (err) {\n                    error = err;\n                }\n                subscriber.error(error);\n            };\n            xhr.onerror = xhrError;\n            xhrError.request = request;\n            xhrError.subscriber = this;\n            xhrError.progressSubscriber = progressSubscriber;\n        }\n        function xhrReadyStateChange(e) {\n            return;\n        }\n        xhr.onreadystatechange = xhrReadyStateChange;\n        xhrReadyStateChange.subscriber = this;\n        xhrReadyStateChange.progressSubscriber = progressSubscriber;\n        xhrReadyStateChange.request = request;\n        function xhrLoad(e) {\n            const { subscriber, progressSubscriber, request } = xhrLoad;\n            if (this.readyState === 4) {\n                let status = this.status === 1223 ? 204 : this.status;\n                let response = (this.responseType === 'text' ? (this.response || this.responseText) : this.response);\n                if (status === 0) {\n                    status = response ? 200 : 0;\n                }\n                if (status < 400) {\n                    if (progressSubscriber) {\n                        progressSubscriber.complete();\n                    }\n                    subscriber.next(e);\n                    subscriber.complete();\n                }\n                else {\n                    if (progressSubscriber) {\n                        progressSubscriber.error(e);\n                    }\n                    let error;\n                    try {\n                        error = new AjaxError('ajax error ' + status, this, request);\n                    }\n                    catch (err) {\n                        error = err;\n                    }\n                    subscriber.error(error);\n                }\n            }\n        }\n        xhr.onload = xhrLoad;\n        xhrLoad.subscriber = this;\n        xhrLoad.progressSubscriber = progressSubscriber;\n        xhrLoad.request = request;\n    }\n    unsubscribe() {\n        const { done, xhr } = this;\n        if (!done && xhr && xhr.readyState !== 4 && typeof xhr.abort === 'function') {\n            xhr.abort();\n        }\n        super.unsubscribe();\n    }\n}\nexport class AjaxResponse {\n    constructor(originalEvent, xhr, request) {\n        this.originalEvent = originalEvent;\n        this.xhr = xhr;\n        this.request = request;\n        this.status = xhr.status;\n        this.responseType = xhr.responseType || request.responseType;\n        this.response = parseXhrResponse(this.responseType, xhr);\n    }\n}\nconst AjaxErrorImpl = (() => {\n    function AjaxErrorImpl(message, xhr, request) {\n        Error.call(this);\n        this.message = message;\n        this.name = 'AjaxError';\n        this.xhr = xhr;\n        this.request = request;\n        this.status = xhr.status;\n        this.responseType = xhr.responseType || request.responseType;\n        this.response = parseXhrResponse(this.responseType, xhr);\n        return this;\n    }\n    AjaxErrorImpl.prototype = Object.create(Error.prototype);\n    return AjaxErrorImpl;\n})();\nexport const AjaxError = AjaxErrorImpl;\nfunction parseJson(xhr) {\n    if ('response' in xhr) {\n        return xhr.responseType ? xhr.response : JSON.parse(xhr.response || xhr.responseText || 'null');\n    }\n    else {\n        return JSON.parse(xhr.responseText || 'null');\n    }\n}\nfunction parseXhrResponse(responseType, xhr) {\n    switch (responseType) {\n        case 'json':\n            return parseJson(xhr);\n        case 'xml':\n            return xhr.responseXML;\n        case 'text':\n        default:\n            return ('response' in xhr) ? xhr.response : xhr.responseText;\n    }\n}\nfunction AjaxTimeoutErrorImpl(xhr, request) {\n    AjaxError.call(this, 'ajax timeout', xhr, request);\n    this.name = 'AjaxTimeoutError';\n    return this;\n}\nexport const AjaxTimeoutError = AjaxTimeoutErrorImpl;\n","import { AjaxObservable } from './AjaxObservable';\nexport const ajax = (() => AjaxObservable.create)();\n","const __window = typeof window !== 'undefined' && window;\nconst __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n    self instanceof WorkerGlobalScope && self;\nconst __global = typeof global !== 'undefined' && global;\nconst _root = __window || __global || __self;\n(function () {\n    if (!_root) {\n        throw new Error('RxJS could not find any global context (window, self, global)');\n    }\n})();\nexport { _root as root };\n"],"names":[],"sourceRoot":"webpack:///"}